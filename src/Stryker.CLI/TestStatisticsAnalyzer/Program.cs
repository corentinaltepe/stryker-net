using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using Newtonsoft.Json;
using Stryker.Core.Mutants;
using Stryker.Core.Reporters;

namespace TestStatisticsAnalyzer
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            if (args.Length != 1 || !args[0].EndsWith("json"))
            {
                Console.WriteLine("Usage: TestStatisticsAnalyzer 'statistics.json' file generated by Stryker-mutator");
                return;
            }

            var report =
                JsonConvert.DeserializeObject<TestStatisticsReport>(File.ReadAllText(args[0]));
            var data = new Data();
            foreach (var reportTest in report.Tests)
            {
                data.AddTest(reportTest);
            }

            foreach (var jsonTestedMutant in report.Mutants)
            {
                data.AddMutant(jsonTestedMutant);
                foreach (var test in jsonTestedMutant.Tests)
                {
                    data.GetTest(test.Key).AddMutant(data.GetMutant(jsonTestedMutant.Id.ToString()), !test.Value);
                }
            }

            var useless = data.UselessTests();
            if (useless.Count > 0)
            {
                Console.WriteLine($"{useless.Count} tests looks useless because they kill no mutants:{string.Join(',', useless.Select(x => x.Name))}");
                foreach (var testStatistics in useless)
                {
                    if (testStatistics.TestedCount == 0)
                    {
                        Console.WriteLine($"{testStatistics.Name} tests no mutants. Is it necessary?");
                    }
                    else
                    {
                        Console.WriteLine($"{testStatistics} test {testStatistics.TestedCount} mutants without killing any. Maybe assertions are missing? Mutants:{string.Join(',', testStatistics.Tested)}.");
                    }
                }
            }

            var survivors = data.Survivors();
            if (survivors.Count > 0)
            {
                Console.WriteLine($"{survivors.Count} mutants survived:{string.Join(',', survivors)}");
                // todo, look for tests that cover them
            }
        }
    }

    internal class Data
    {
        private readonly IDictionary<string, MutantDescription> _mutants = new Dictionary<string, MutantDescription>();
        private readonly IDictionary<string, TestStatistics> _tests = new Dictionary<string, TestStatistics>();

        public ICollection<TestStatistics> TestStatistics => _tests.Values;
        public ICollection<MutantDescription> MutantDescription => _mutants.Values;

        public void AddMutant(MutantDescription mutant)
        {
            _mutants.Add(mutant.Id.ToString(), mutant);
        }

        public void AddTest(TestStatistics testStatistics)
        {
            _tests.Add(testStatistics.Guid, testStatistics);
        }

        public MutantDescription GetMutant(string id) => _mutants[id];

        public TestStatistics GetTest(string id)=> _tests[id];

    }

    internal static class Queries
    {
        public static IReadOnlyCollection<TestStatistics> UselessTests(this Data data)
        {
            return data.TestStatistics.Where(t => t.KilledCount == 0).ToImmutableList();
        }
        public static IReadOnlyCollection<MutantDescription> Survivors(this Data data)
        {
            return data.MutantDescription.Where(t => t.Status == MutantStatus.Survived).ToImmutableList();
        }
    }

    internal class MutantDescription
    {
        public MutantDescription(int id, string replacement, MutantStatus status)
        {
            Id = id;
            Replacement = replacement;
            Status = status;
        }

        public int Id { get; }
        public string Replacement { get; }
        public MutantStatus Status { get; }

        protected bool Equals(MutantDescription other)
        {
            return Id == other.Id;
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != GetType()) return false;
            return Equals((MutantDescription) obj);
        }

        public override int GetHashCode()
        {
            return Id;
        }

        public static implicit operator MutantDescription(JsonTestedMutant mutant)
        {
            return new MutantDescription(mutant.Id, mutant.Replacement, mutant.Status);
        }

        public override string ToString() => $"[{Id}, {Replacement}]";
    }

    internal class TestStatistics
    {
        private readonly TestDescription desc;
        private readonly IList<MutantDescription> killedMutants = new List<MutantDescription>();
        private readonly IList<MutantDescription> testedMutants = new List<MutantDescription>();

        public TestStatistics(string id, string name)
        {
            this.desc = new TestDescription(id, name);
        }

        public string Guid => desc.Guid;
        public string Name => desc.Name;

        public int TestedCount => testedMutants.Count;
        public int KilledCount => killedMutants.Count;
        public IReadOnlyCollection<MutantDescription> Tested => testedMutants.ToImmutableList();

        public static implicit operator TestStatistics(JsonTest desc)
        {
            return new TestStatistics(desc.Guid, desc.Name);
        }

        public void AddMutant(MutantDescription mutant, bool killed)
        {
            if (killed)
            {
                killedMutants.Add(mutant);
            }
            testedMutants.Add(mutant);
        }
    }
}